{"file_contents":{"app.py":{"content":"import streamlit as st\nimport io\nimport os\nfrom gtts import gTTS\nimport base64\nfrom tamil_dictionary import TAMIL_WORD_MAPPING\nfrom openai_tamil_translator import translate_classical_tamil_with_ai, get_word_by_word_translation\nfrom premium_tts_service import PremiumTTSService\n\ndef preprocess_classical_tamil(text):\n    \"\"\"Advanced preprocessing for classical Tamil texts to improve TTS pronunciation\"\"\"\n    import re\n    \n    # Remove or normalize various Tamil script variations\n    text = text.replace('‡Øç', '‡Øç')  # Normalize virama\n    \n    # Handle sandhi (euphonic combinations) - basic cases\n    # Replace common classical combinations with space-separated words\n    sandhi_patterns = {\n        r'‡Æ§‡Æ≤‡Øç‡Æ≤‡ØÅ‡ÆÆ‡Øç': '‡Æ§‡Ææ‡Æ©‡Øç ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡ØÅ‡ÆÆ‡Øç',\n        r'‡Æï‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç': '‡Æï‡Æ£‡Øç‡Æü‡ØÅ ‡Æâ‡ÆÆ‡Øç',\n        r'‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡ØÅ‡ÆÆ‡Øç': '‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡ØÅ ‡Æâ‡ÆÆ‡Øç',\n        r'‡Æµ‡Æ®‡Øç‡Æ§‡ØÅ‡ÆÆ‡Øç': '‡Æµ‡Æ®‡Øç‡Æ§‡ØÅ ‡Æâ‡ÆÆ‡Øç',\n        r'‡Æ™‡Øã‡Æ©‡ØÅ‡ÆÆ‡Øç': '‡Æ™‡Øã‡Æ© ‡Æâ‡ÆÆ‡Øç',\n    }\n    \n    for pattern, replacement in sandhi_patterns.items():\n        text = re.sub(pattern, replacement, text, flags=re.IGNORECASE)\n    \n    # Handle classical Tamil phonetic variations\n    phonetic_normalizations = {\n        r'‡Æ¥‡Øç': '‡Æ≥‡Øç',  # Simplify retroflex for TTS\n        r'‡Æ±‡Øç‡Æ±': '‡Æü‡Øç‡Æü',  # Common sound changes\n        r'‡Æ©‡Øç‡Æ©': '‡Æ£‡Øç‡Æ£',  # Nasal variations\n    }\n    \n    for pattern, replacement in phonetic_normalizations.items():\n        text = re.sub(pattern, replacement, text)\n    \n    # Handle classical verb endings - convert to modern forms\n    classical_verb_patterns = {\n        r'(\\w+)‡ØÅ‡ÆÆ‡Øá$': r'\\1‡ØÅ‡ÆÆ‡Øç',  # -ume to -um\n        r'(\\w+)‡Æµ‡Øá$': r'\\1‡Æµ‡Æ§‡ØÅ',   # -ve to -vadhu\n        r'(\\w+)‡Æ§‡Øá$': r'\\1‡Æ§‡Æ§‡Øá',   # -the to -thathe\n    }\n    \n    words = text.split()\n    normalized_words = []\n    \n    for word in words:\n        original_word = word\n        # Apply classical verb patterns\n        for pattern, replacement in classical_verb_patterns.items():\n            word = re.sub(pattern, replacement, word)\n        \n        normalized_words.append(word)\n    \n    return ' '.join(normalized_words)\n\ndef replace_old_tamil_words(text):\n    \"\"\"Replace old Tamil words with modern equivalents using dictionary mapping\"\"\"\n    words = text.split()\n    replaced_words = []\n    \n    for word in words:\n        # Remove punctuation for matching\n        clean_word = word.strip('.,!?;:\"()[]{}')\n        punctuation = word[len(clean_word):]\n        \n        # Check if word exists in mapping dictionary\n        if clean_word in TAMIL_WORD_MAPPING:\n            replaced_words.append(TAMIL_WORD_MAPPING[clean_word] + punctuation)\n        else:\n            replaced_words.append(word)\n    \n    return ' '.join(replaced_words)\n\ndef text_to_speech_tamil(text, provider='gtts', voice_accent='com', speech_speed=False):\n    \"\"\"Convert Tamil text to speech using premium TTS services\"\"\"\n    try:\n        tts_service = PremiumTTSService()\n        \n        if provider == 'gtts':\n            audio_bytes = tts_service.generate_speech(\n                text, \n                provider='gtts', \n                voice_accent=voice_accent, \n                slow=speech_speed\n            )\n        elif provider == 'elevenlabs':\n            audio_bytes = tts_service.generate_speech(text, provider='elevenlabs')\n        elif provider == 'google_cloud':\n            audio_bytes = tts_service.generate_speech(text, provider='google_cloud')\n        elif provider == 'azure':\n            audio_bytes = tts_service.generate_speech(text, provider='azure')\n        else:\n            # Fallback to gTTS\n            audio_bytes = tts_service.generate_speech(\n                text, \n                provider='gtts', \n                voice_accent=voice_accent, \n                slow=speech_speed\n            )\n        \n        return audio_bytes\n        \n    except Exception as e:\n        st.error(f\"Error generating speech: {str(e)}\")\n        return None\n\n\ndef main():\n    st.title(\"Tamil Poetry Text-to-Speech Converter\")\n    st.markdown(\"Convert Tamil Unicode poetry text to MP3 audio with voice narration\")\n    \n    # Text input section\n    st.header(\"üìù Enter Tamil Poetry Text\")\n    tamil_text = st.text_area(\n        \"Paste your Tamil Unicode poetry text here:\",\n        height=200,\n        placeholder=\"‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç ‡Æï‡Æµ‡Æø‡Æ§‡Øà ‡Æâ‡Æ∞‡Øà‡ÆØ‡Øà ‡Æá‡Æô‡Øç‡Æï‡Øá ‡Æ™‡Øá‡Æ∏‡Øç‡∞ü‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Æµ‡ØÅ‡ÆÆ‡Øç...\"\n    )\n    \n    # Text processing and voice options\n    st.header(\"üîÑ Text Processing & Voice Options\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        translation_mode = st.selectbox(\n            \"Translation Method\",\n            options=[\n                (\"dictionary\", \"Dictionary-based (Fast)\"),\n                (\"ai\", \"AI-powered (Advanced)\"),\n                (\"both\", \"Both Dictionary + AI\")\n            ],\n            format_func=lambda x: x[1],\n            help=\"Choose how to modernize classical Tamil words\"\n        )\n        \n        use_preprocessing = st.checkbox(\n            \"Advanced classical Tamil preprocessing\",\n            value=True,\n            help=\"Normalize classical Tamil script, handle sandhi, and improve phonetic representation for TTS\"\n        )\n        \n        speech_speed = st.checkbox(\n            \"Slow speech for better clarity\",\n            value=False,\n            help=\"Enable for slower, more deliberate pronunciation\"\n        )\n    \n    with col2:\n        tts_provider = st.selectbox(\n            \"TTS Provider\",\n            options=[\n                (\"gtts\", \"Google TTS (Free)\"),\n                (\"elevenlabs\", \"ElevenLabs (Premium)\"),\n                (\"google_cloud\", \"Google Cloud (Professional)\"),\n                (\"azure\", \"Microsoft Azure (Professional)\")\n            ],\n            format_func=lambda x: x[1],\n            help=\"Choose text-to-speech quality level. Premium services require API keys.\"\n        )\n        \n        # Show accent options only for gTTS\n        if tts_provider[0] == 'gtts':\n            voice_accent = st.selectbox(\n                \"Voice Accent Region\",\n                options=[\n                    (\"com\", \"Global (Default)\"),\n                    (\"co.in\", \"India\"),\n                    (\"com.au\", \"Australia\"),\n                    (\"co.uk\", \"United Kingdom\"),\n                    (\"com.sg\", \"Singapore\")\n                ],\n                format_func=lambda x: x[1],\n                help=\"Different Google domains may provide slight accent variations\"\n            )\n            selected_accent = voice_accent[0]\n        else:\n            selected_accent = 'com'\n    \n    if tamil_text.strip():\n        # Show original text\n        st.subheader(\"Original Text:\")\n        st.text_area(\"Original Text\", value=tamil_text, height=100, disabled=True, key=\"original\", label_visibility=\"collapsed\")\n        \n        # Process text with preprocessing and translation\n        processed_text = tamil_text\n        translation_changes = []\n        \n        # Apply advanced preprocessing if enabled\n        if use_preprocessing:\n            processed_text = preprocess_classical_tamil(processed_text)\n        \n        # Apply translation based on selected method\n        selected_translation_mode = translation_mode[0]\n        \n        if selected_translation_mode == \"dictionary\":\n            processed_text = replace_old_tamil_words(processed_text)\n        elif selected_translation_mode == \"ai\":\n            try:\n                with st.spinner(\"AI is analyzing and modernizing your classical Tamil text...\"):\n                    ai_result = translate_classical_tamil_with_ai(processed_text)\n                    processed_text = ai_result['modernized_text']\n                    translation_changes = ai_result.get('changes_made', [])\n                    confidence = ai_result.get('confidence', 0.0)\n                    \n                    if confidence < 0.7:\n                        st.warning(f\"AI translation confidence is {confidence:.1%}. Results may need review.\")\n            except Exception as e:\n                st.error(f\"AI translation failed: {str(e)}. Falling back to dictionary method.\")\n                processed_text = replace_old_tamil_words(processed_text)\n        elif selected_translation_mode == \"both\":\n            # First apply dictionary, then AI\n            processed_text = replace_old_tamil_words(processed_text)\n            try:\n                with st.spinner(\"Enhancing with AI translation...\"):\n                    ai_result = translate_classical_tamil_with_ai(processed_text)\n                    processed_text = ai_result['modernized_text']\n                    translation_changes = ai_result.get('changes_made', [])\n            except Exception as e:\n                st.warning(f\"AI enhancement failed: {str(e)}. Using dictionary translation only.\")\n        \n        # Show processed text if different from original\n        if processed_text != tamil_text:\n            processing_description = []\n            if use_preprocessing:\n                processing_description.append(\"classical Tamil preprocessing\")\n            if selected_translation_mode in [\"dictionary\", \"both\"]:\n                processing_description.append(\"dictionary-based word replacements\")\n            if selected_translation_mode in [\"ai\", \"both\"]:\n                processing_description.append(\"AI-powered translation\")\n            \n            description = \" and \".join(processing_description)\n            st.subheader(f\"Processed Text (with {description}):\")\n            st.text_area(\"Processed Text\", value=processed_text, height=100, disabled=True, key=\"processed\", label_visibility=\"collapsed\")\n            \n            # Show AI translation changes\n            if translation_changes and selected_translation_mode in [\"ai\", \"both\"]:\n                st.success(\"ü§ñ AI Translation Changes:\")\n                for i, change in enumerate(translation_changes[:5], 1):  # Show max 5 changes\n                    st.write(f\"{i}. {change}\")\n                if len(translation_changes) > 5:\n                    st.write(f\"... and {len(translation_changes) - 5} more changes\")\n            \n            # Show dictionary replacements made (if enabled)\n            elif selected_translation_mode == \"dictionary\":\n                original_words = set(tamil_text.split())\n                replacements_made = []\n                for orig_word in original_words:\n                    clean_orig = orig_word.strip('.,!?;:\"()[]{}')\n                    if clean_orig in TAMIL_WORD_MAPPING:\n                        replacements_made.append(f\"{clean_orig} ‚Üí {TAMIL_WORD_MAPPING[clean_orig]}\")\n                \n                if replacements_made:\n                    st.info(f\"üìñ Dictionary replacements: {', '.join(replacements_made)}\")\n            \n            # Show preprocessing changes (if enabled)\n            if use_preprocessing and selected_translation_mode not in [\"dictionary\", \"ai\", \"both\"]:\n                st.info(\"Text normalized for better TTS pronunciation (sandhi resolution, phonetic adjustments)\")\n        else:\n            # Show info even if text didn't change\n            processing_types = []\n            if use_preprocessing:\n                processing_types.append(\"classical Tamil preprocessing\")\n            processing_types.append(f\"{translation_mode[1].lower()}\")\n            \n            st.info(f\"Text processing enabled ({', '.join(processing_types)}) but no changes were needed for this text.\")\n        \n        # Audio generation section\n        st.header(\"üéµ Audio Generation\")\n        \n        col1, col2 = st.columns([1, 1])\n        \n        with col1:\n            if st.button(\"üîä Generate Audio\", type=\"primary\"):\n                with st.spinner(f\"Generating audio using {tts_provider[1]}... Please wait...\"):\n                    audio_bytes = text_to_speech_tamil(\n                        processed_text, \n                        provider=tts_provider[0], \n                        voice_accent=selected_accent, \n                        speech_speed=speech_speed\n                    )\n                    \n                    if audio_bytes:\n                        st.success(f\"Audio generated successfully with {tts_provider[1]}!\")\n                        \n                        # Store audio in session state\n                        st.session_state.audio_bytes = audio_bytes\n                        st.session_state.audio_ready = True\n                        st.session_state.tts_provider = tts_provider[1]\n        \n        # Audio playback and download section\n        if hasattr(st.session_state, 'audio_ready') and st.session_state.audio_ready:\n            st.header(\"üéß Audio Playback & Download\")\n            \n            # Audio player\n            st.audio(st.session_state.audio_bytes, format='audio/mp3')\n            \n            # Download button\n            filename = \"tamil_poetry_audio.mp3\"\n            st.download_button(\n                label=\"üì• Download MP3\",\n                data=st.session_state.audio_bytes,\n                file_name=filename,\n                mime=\"audio/mp3\"\n            )\n            \n            # File info\n            audio_size = len(st.session_state.audio_bytes)\n            st.info(f\"Audio file size: {audio_size / 1024:.1f} KB\")\n    \n    else:\n        st.info(\"üëÜ Please enter Tamil text above to generate audio\")\n    \n    # Instructions section\n    with st.expander(\"‚ÑπÔ∏è How to use this app\"):\n        st.markdown(\"\"\"\n        1. **Enter Text**: Paste your Tamil Unicode poetry text in the text area above\n        2. **Word Processing**: Enable modern word replacement to convert archaic Tamil words\n        3. **Generate Audio**: Click the 'Generate Audio' button to create MP3 audio\n        4. **Play & Download**: Use the audio player to listen and download the MP3 file\n        \n        **Supported Features:**\n        - Tamil Unicode text input\n        - Old Tamil to modern Tamil word conversion\n        - High-quality text-to-speech using Google's TTS\n        - MP3 audio generation and download\n        - Built-in audio player\n        \"\"\")\n    \n    # Technical info\n    with st.expander(\"üîß Technical Information\"):\n        st.markdown(\"\"\"\n        - **Text-to-Speech Engine**: Google Text-to-Speech (gTTS)\n        - **Language**: Tamil (ta)\n        - **Audio Format**: MP3\n        - **Word Replacement**: Custom dictionary mapping for old Tamil words\n        \"\"\")\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":14513},"db_manager.py":{"content":"\"\"\"\nDatabase manager for custom Tamil dictionary entries\n\"\"\"\nimport os\nimport psycopg2\nimport streamlit as st\nfrom typing import Dict, List, Tuple, Optional\n\ndef get_db_connection():\n    \"\"\"Get database connection from environment variables\"\"\"\n    try:\n        conn = psycopg2.connect(\n            host=os.getenv('PGHOST'),\n            database=os.getenv('PGDATABASE'),\n            user=os.getenv('PGUSER'),\n            password=os.getenv('PGPASSWORD'),\n            port=os.getenv('PGPORT', '5432')\n        )\n        return conn\n    except Exception as e:\n        st.error(f\"Database connection error: {str(e)}\")\n        return None\n\ndef create_dictionary_table():\n    \"\"\"Create the custom_dictionary table if it doesn't exist\"\"\"\n    conn = get_db_connection()\n    if not conn:\n        return False\n    \n    try:\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS custom_dictionary (\n                id SERIAL PRIMARY KEY,\n                old_word VARCHAR(255) NOT NULL UNIQUE,\n                modern_word VARCHAR(255) NOT NULL,\n                description TEXT,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        conn.commit()\n        cursor.close()\n        conn.close()\n        return True\n    except Exception as e:\n        st.error(f\"Error creating dictionary table: {str(e)}\")\n        if conn:\n            conn.close()\n        return False\n\ndef load_custom_dictionary() -> Dict[str, str]:\n    \"\"\"Load custom dictionary entries from database\"\"\"\n    conn = get_db_connection()\n    if not conn:\n        return {}\n    \n    try:\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT old_word, modern_word FROM custom_dictionary\")\n        entries = cursor.fetchall()\n        cursor.close()\n        conn.close()\n        \n        return {old: modern for old, modern in entries}\n    except Exception as e:\n        st.error(f\"Error loading custom dictionary: {str(e)}\")\n        if conn:\n            conn.close()\n        return {}\n\ndef add_dictionary_entry(old_word: str, modern_word: str, description: str = \"\") -> bool:\n    \"\"\"Add or update a dictionary entry\"\"\"\n    conn = get_db_connection()\n    if not conn:\n        return False\n    \n    try:\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            INSERT INTO custom_dictionary (old_word, modern_word, description)\n            VALUES (%s, %s, %s)\n            ON CONFLICT (old_word)\n            DO UPDATE SET \n                modern_word = EXCLUDED.modern_word,\n                description = EXCLUDED.description,\n                updated_at = CURRENT_TIMESTAMP\n        \"\"\", (old_word.strip(), modern_word.strip(), description.strip()))\n        conn.commit()\n        cursor.close()\n        conn.close()\n        return True\n    except Exception as e:\n        st.error(f\"Error adding dictionary entry: {str(e)}\")\n        if conn:\n            conn.close()\n        return False\n\ndef delete_dictionary_entry(old_word: str) -> bool:\n    \"\"\"Delete a dictionary entry\"\"\"\n    conn = get_db_connection()\n    if not conn:\n        return False\n    \n    try:\n        cursor = conn.cursor()\n        cursor.execute(\"DELETE FROM custom_dictionary WHERE old_word = %s\", (old_word,))\n        deleted = cursor.rowcount > 0\n        conn.commit()\n        cursor.close()\n        conn.close()\n        return deleted\n    except Exception as e:\n        st.error(f\"Error deleting dictionary entry: {str(e)}\")\n        if conn:\n            conn.close()\n        return False\n\ndef get_all_dictionary_entries() -> List[Tuple[str, str, str]]:\n    \"\"\"Get all dictionary entries with descriptions\"\"\"\n    conn = get_db_connection()\n    if not conn:\n        return []\n    \n    try:\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            SELECT old_word, modern_word, COALESCE(description, '') \n            FROM custom_dictionary \n            ORDER BY old_word\n        \"\"\")\n        entries = cursor.fetchall()\n        cursor.close()\n        conn.close()\n        return entries\n    except Exception as e:\n        st.error(f\"Error fetching dictionary entries: {str(e)}\")\n        if conn:\n            conn.close()\n        return []\n\ndef search_dictionary_entries(search_term: str) -> List[Tuple[str, str, str]]:\n    \"\"\"Search dictionary entries by old word or modern word\"\"\"\n    conn = get_db_connection()\n    if not conn:\n        return []\n    \n    try:\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            SELECT old_word, modern_word, COALESCE(description, '')\n            FROM custom_dictionary \n            WHERE old_word ILIKE %s OR modern_word ILIKE %s\n            ORDER BY old_word\n        \"\"\", (f'%{search_term}%', f'%{search_term}%'))\n        entries = cursor.fetchall()\n        cursor.close()\n        conn.close()\n        return entries\n    except Exception as e:\n        st.error(f\"Error searching dictionary entries: {str(e)}\")\n        if conn:\n            conn.close()\n        return []\n\n# Initialize database on import\nif __name__ != \"__main__\":\n    create_dictionary_table()","size_bytes":5109},"openai_tamil_translator.py":{"content":"\"\"\"\nOpenAI-powered Tamil word translator for classical to modern Tamil conversion\nwith web research capabilities for classical Tamil poetry context\n\"\"\"\nimport json\nimport os\nimport re\nfrom openai import OpenAI\n\n# the newest OpenAI model is \"gpt-5\" which was released August 7, 2025.\n# do not change this unless explicitly requested by the user\n\nOPENAI_API_KEY = os.environ.get(\"OPENAI_API_KEY\")\nopenai = OpenAI(api_key=OPENAI_API_KEY)\n\ndef translate_classical_tamil_with_ai(text: str, context_info: dict = None, use_web_research: bool = True) -> dict:\n    \"\"\"Use OpenAI to provide meaning-based translation of classical Tamil to modern Tamil\n    \n    Args:\n        text: Classical Tamil text to translate\n        context_info: Optional context from web research\n        use_web_research: Whether to include web research context in translation\n    \n    Returns:\n        Dict with original_text, modernized_text, meaning_explanation, context_info, translation_method, changes_made\n    \"\"\"\n    try:\n        # If no context provided and web research is enabled, try to get context\n        if context_info is None and use_web_research:\n            context_info = research_classical_tamil_context(text)\n        \n        # Build enhanced prompt with context\n        context_section = \"\"\n        if context_info:\n            context_section = f\"\"\"\n            \nCONTEXTUAL INFORMATION:\n            Historical Period: {context_info.get('period', 'Classical Tamil period')}\n            Literary Context: {context_info.get('context', 'Classical Tamil poetry')}\n            Common Themes: {', '.join(context_info.get('themes', ['classical poetry']))}\n            Cultural Significance: {context_info.get('literary_significance', 'Traditional Tamil literature')}\n            \"\"\"\n        \n        prompt = f\"\"\"\n        You are an expert Tamil scholar specializing in classical Tamil literature, poetic meaning, and modern Tamil expression.\n        \n        TASK: Provide a meaning-based translation of this classical Tamil poetry text into modern Tamil suitable for text-to-speech.\n        \n        ORIGINAL TEXT: \"{text}\"\n        {context_section}\n        \n        TRANSLATION APPROACH:\n        1. Focus on conveying the complete poetic meaning and emotional content, not just word-for-word substitution\n        2. Understand the classical Tamil literary devices, metaphors, and cultural references\n        3. Express the essence and sentiment in clear, modern Tamil that preserves the artistic intent\n        4. Maintain poetic beauty while ensuring TTS clarity\n        5. Consider the historical and cultural context in your interpretation\n        6. Explain the deeper meaning and significance of the poetry\n        \n        REQUIREMENTS:\n        - Modernized text should be naturally flowing modern Tamil\n        - Preserve the emotional and artistic essence of the original\n        - Make cultural and literary references accessible to modern readers\n        - Ensure pronunciation clarity for text-to-speech engines\n        \n        Respond with JSON in this format:\n        {{\n            \"modernized_text\": \"beautifully expressed modern Tamil that captures the full meaning\",\n            \"meaning_explanation\": \"detailed explanation of the poetic meaning, themes, and significance\",\n            \"changes_made\": [\"list of key modernization changes made\"],\n            \"confidence\": 0.95,\n            \"literary_analysis\": \"brief analysis of the poetic devices and cultural elements\"\n        }}\n        \"\"\"\n        \n        response = openai.chat.completions.create(\n            model=\"gpt-5\",\n            messages=[\n                {\n                    \"role\": \"system\",\n                    \"content\": \"You are a distinguished Tamil literature scholar with expertise in classical poetry interpretation and modern Tamil expression. Provide meaning-based translations that capture the artistic and cultural essence. Respond only in valid JSON format.\"\n                },\n                {\"role\": \"user\", \"content\": prompt}\n            ],\n            response_format={\"type\": \"json_object\"},\n            temperature=0.4  # Balanced for creativity while maintaining consistency\n        )\n        \n        content = response.choices[0].message.content\n        if not content:\n            raise Exception(\"Empty response from OpenAI\")\n        \n        ai_result = json.loads(content)\n        \n        # Construct comprehensive response\n        result = {\n            \"original_text\": text,\n            \"modernized_text\": ai_result.get(\"modernized_text\", text),\n            \"meaning_explanation\": ai_result.get(\"meaning_explanation\", \"AI-powered meaning-based translation of classical Tamil poetry.\"),\n            \"context_info\": context_info or {},\n            \"translation_method\": \"AI-powered with context\",\n            \"changes_made\": ai_result.get(\"changes_made\", []),\n            \"confidence\": ai_result.get(\"confidence\", 0.8),\n            \"literary_analysis\": ai_result.get(\"literary_analysis\", \"Classical Tamil poetry with traditional elements.\")\n        }\n        \n        return result\n        \n    except Exception as e:\n        print(f\"AI translation error: {str(e)}\")\n        # Return to fallback method\n        return _fallback_meaning_based_translation(text, context_info)\n\ndef get_comprehensive_translation(text: str, use_ai: bool = True, use_web_research: bool = True) -> dict:\n    \"\"\"Main entry point for comprehensive classical Tamil translation\n    \n    Args:\n        text: Classical Tamil text to translate\n        use_ai: Whether to attempt AI translation first (falls back if fails)\n        use_web_research: Whether to include web research context\n    \n    Returns:\n        Comprehensive translation with meaning, context, and analysis\n    \"\"\"\n    try:\n        # Get contextual information first if web research enabled\n        context_info = None\n        if use_web_research:\n            try:\n                context_info = research_classical_tamil_context(text)\n            except Exception as e:\n                print(f\"Web research failed: {str(e)}\")\n                context_info = _fallback_classical_context()\n        \n        # Attempt AI translation first if enabled\n        if use_ai:\n            try:\n                ai_result = translate_classical_tamil_with_ai(text, context_info, use_web_research)\n                ai_result['translation_method'] = 'AI-powered'\n                return ai_result\n            except Exception as e:\n                print(f\"AI translation failed: {str(e)}. Falling back to context-based method.\")\n        \n        # Use fallback method\n        fallback_result = _fallback_meaning_based_translation(text, context_info)\n        return fallback_result\n        \n    except Exception as e:\n        print(f\"Comprehensive translation error: {str(e)}\")\n        return {\n            \"original_text\": text,\n            \"modernized_text\": text,\n            \"meaning_explanation\": \"Translation system temporarily unavailable. This appears to be classical Tamil text.\",\n            \"context_info\": _fallback_classical_context(),\n            \"translation_method\": \"Emergency fallback\",\n            \"changes_made\": [],\n            \"confidence\": 0.1,\n            \"literary_analysis\": \"Classical Tamil text requiring expert interpretation.\"\n        }\n\ndef get_word_by_word_translation(text: str, context_info: dict = None) -> dict:\n    \"\"\"Get detailed word-by-word translation mapping with enhanced fallback\"\"\"\n    try:\n        prompt = f\"\"\"\n        Analyze this classical Tamil text word by word and provide modern equivalents with meaning context:\n        \n        \"{text}\"\n        \n        For each classical/archaic word that needs modernization, provide:\n        1. The modern equivalent word\n        2. Brief meaning explanation for significant poetic terms\n        \n        Context: This appears to be classical Tamil poetry with traditional themes.\n        \n        Respond with JSON in this format:\n        {{\n            \"word_mappings\": {{\n                \"classical_word1\": {{\"modern\": \"modern_word1\", \"meaning\": \"explanation\"}},\n                \"classical_word2\": {{\"modern\": \"modern_word2\", \"meaning\": \"explanation\"}}\n            }},\n            \"analysis\": \"Brief explanation of the translation approach and poetic context\"\n        }}\n        \"\"\"\n        \n        response = openai.chat.completions.create(\n            model=\"gpt-5\",\n            messages=[\n                {\n                    \"role\": \"system\", \n                    \"content\": \"You are a Tamil linguistics expert specializing in classical poetry analysis. Provide word-by-word mappings with meaning context. Respond only in valid JSON format.\"\n                },\n                {\"role\": \"user\", \"content\": prompt}\n            ],\n            response_format={\"type\": \"json_object\"},\n            temperature=0.2\n        )\n        \n        content = response.choices[0].message.content\n        if not content:\n            raise Exception(\"Empty response from OpenAI\")\n        \n        ai_result = json.loads(content)\n        \n        return {\n            \"word_mappings\": ai_result.get(\"word_mappings\", {}),\n            \"analysis\": ai_result.get(\"analysis\", \"AI word-by-word analysis of classical Tamil text.\"),\n            \"translation_method\": \"AI-powered word analysis\"\n        }\n        \n    except Exception as e:\n        print(f\"AI word mapping error: {str(e)}. Using fallback method.\")\n        return _fallback_word_mapping(text, context_info)\n\ndef _fallback_word_mapping(text: str, context_info: dict = None) -> dict:\n    \"\"\"Fallback word-by-word mapping using dictionary and context\"\"\"\n    try:\n        from tamil_dictionary import TAMIL_WORD_MAPPING\n        \n        words = text.split()\n        word_mappings = {}\n        mapped_count = 0\n        \n        for word in words:\n            clean_word = word.strip('.,!?;:\"()[]{}‡º≠')\n            \n            if clean_word in TAMIL_WORD_MAPPING:\n                modern_word = TAMIL_WORD_MAPPING[clean_word]\n                if clean_word != modern_word:\n                    word_mappings[clean_word] = {\n                        \"modern\": modern_word,\n                        \"meaning\": f\"Classical word modernized for clarity\"\n                    }\n                    mapped_count += 1\n        \n        # Add context-based analysis\n        themes = context_info.get('themes', ['classical poetry']) if context_info else ['classical poetry']\n        theme_text = ', '.join(themes[:2])\n        \n        analysis = f\"Dictionary-based word mapping found {mapped_count} classical terms to modernize. Text appears to contain {theme_text} themes typical of classical Tamil literature.\"\n        \n        return {\n            \"word_mappings\": word_mappings,\n            \"analysis\": analysis,\n            \"translation_method\": \"Dictionary-based fallback\"\n        }\n        \n    except Exception as e:\n        print(f\"Fallback word mapping error: {str(e)}\")\n        return {\n            \"word_mappings\": {},\n            \"analysis\": \"Word mapping service temporarily unavailable.\",\n            \"translation_method\": \"Minimal fallback\"\n        }\n\ndef extract_key_terms_from_tamil_text(text: str) -> list:\n    \"\"\"Extract key terms and phrases from Tamil text for web search\"\"\"\n    try:\n        # Remove common punctuation and split into words\n        words = re.findall(r'[\\u0B80-\\u0BFF]+', text)  # Tamil Unicode range\n        \n        # Look for significant words (longer than 2 characters)\n        key_terms = [word for word in words if len(word) > 2]\n        \n        # Return first few significant terms for search\n        return key_terms[:5]\n    except Exception:\n        return []\n\ndef generate_research_queries(text: str) -> list:\n    \"\"\"\n    Generate targeted search queries for classical Tamil poetry research.\n    This helper function creates search queries based on the input text.\n    \"\"\"\n    key_terms = extract_key_terms_from_tamil_text(text)\n    search_terms = \" \".join(key_terms[:3]) if key_terms else text[:50]\n    \n    return [\n        f\"classical Tamil poetry {search_terms} literary analysis meaning\",\n        f\"ancient Tamil literature {search_terms} historical period themes\", \n        f\"Tamil sangam literature {search_terms} poet author context\",\n        f\"classical Tamil verses {search_terms} literary significance interpretation\"\n    ]\n\ndef research_classical_tamil_context(text: str, search_results: list = None) -> dict:\n    \"\"\"\n    Analyze classical Tamil poetry and gather contextual information.\n    \n    Args:\n        text: The Tamil text to analyze\n        search_results: Optional list of web search results to analyze\n    \n    Returns:\n        Dictionary with keys: 'context', 'period', 'themes', 'meaning', 'literary_significance'\n    \"\"\"\n    try:\n        context_info = {\n            'context': '',\n            'period': 'Classical Tamil period',\n            'themes': [],\n            'meaning': '',\n            'literary_significance': ''\n        }\n        \n        # If search results are provided, analyze them\n        if search_results and isinstance(search_results, list):\n            # Process and structure the research results\n            all_content = \" \".join(str(result) for result in search_results if result)\n            \n            if all_content:\n                # Extract context information using pattern matching and keywords\n                context_keywords = ['sangam', 'classical', 'ancient', 'medieval', 'chola', 'pandya', 'pallava']\n                period_keywords = ['century', 'BCE', 'CE', 'AD', 'era', 'period', 'dynasty']\n                theme_keywords = ['love', 'war', 'devotion', 'nature', 'heroism', 'spirituality', 'ethics', 'philosophy']\n                \n                # Build context information from search results\n                if any(keyword in all_content.lower() for keyword in context_keywords):\n                    context_info['context'] = \"This appears to be from classical Tamil literature. The text shows characteristics of traditional Tamil poetic forms with themes commonly found in ancient Tamil works.\"\n                \n                # Identify potential historical period\n                for period_word in period_keywords:\n                    if period_word in all_content.lower():\n                        # Look for century mentions or historical periods\n                        period_match = re.search(rf'\\b(\\d+(?:st|nd|rd|th)?\\s+century|sangam\\s+period|chola\\s+period|medieval\\s+tamil)', all_content.lower())\n                        if period_match:\n                            context_info['period'] = period_match.group(1).title()\n                            break\n                \n                # Extract themes\n                found_themes = [theme for theme in theme_keywords if theme in all_content.lower()]\n                context_info['themes'] = found_themes[:4] if found_themes else ['classical poetry', 'literary expression']\n                \n                # Generate meaning summary from search results\n                if len(all_content) > 100:\n                    # Extract meaningful sentences that might contain interpretation\n                    sentences = re.split(r'[.!?]+', all_content)\n                    meaningful_sentences = [s.strip() for s in sentences if len(s.strip()) > 50 and 'tamil' in s.lower()]\n                    if meaningful_sentences:\n                        context_info['meaning'] = meaningful_sentences[0][:200] + \"...\"\n                \n                # Literary significance\n                significance_keywords = ['significant', 'important', 'renowned', 'famous', 'classic', 'masterpiece']\n                if any(keyword in all_content.lower() for keyword in significance_keywords):\n                    context_info['literary_significance'] = \"This text appears to be from a significant work in Tamil literature, representing classical poetic traditions and cultural heritage.\"\n    \n        # Apply text analysis even without web search results\n        key_terms = extract_key_terms_from_tamil_text(text)\n        if key_terms:\n            # Analyze text characteristics for basic context\n            text_length = len(text.split())\n            if text_length > 10:\n                context_info['context'] = \"This appears to be a substantial classical Tamil text, likely poetic in nature based on its structure and length.\"\n            else:\n                context_info['context'] = \"Short classical Tamil text, possibly a verse or poetic line.\"\n        \n        # Ensure all fields have meaningful content\n        _ensure_complete_context(context_info)\n        \n        return context_info\n        \n    except Exception as e:\n        print(f\"Research error: {str(e)}\")\n        return _fallback_classical_context()\n\ndef _ensure_complete_context(context_info: dict) -> None:\n    \"\"\"Ensure all context fields have meaningful content\"\"\"\n    if not context_info['context']:\n        context_info['context'] = \"Classical Tamil poetry text with traditional linguistic patterns and poetic structure.\"\n    \n    if not context_info['meaning']:\n        context_info['meaning'] = \"This appears to be a classical Tamil poetic composition. The exact meaning may require expert interpretation due to archaic language and cultural references.\"\n    \n    if not context_info['literary_significance']:\n        context_info['literary_significance'] = \"Represents the rich tradition of Tamil literature and poetic expression spanning over two millennia.\"\n    \n    if not context_info['themes']:\n        context_info['themes'] = ['classical poetry', 'tamil literature']\n\ndef _fallback_meaning_based_translation(text: str, context_info: dict = None) -> dict:\n    \"\"\"Provide intelligent fallback translation when OpenAI is unavailable\n    \n    This uses contextual analysis + enhanced dictionary to provide meaning-based translation\n    \"\"\"\n    try:\n        # Get context if not provided\n        if context_info is None:\n            context_info = research_classical_tamil_context(text)\n        \n        # Apply enhanced dictionary translation\n        from tamil_dictionary import TAMIL_WORD_MAPPING\n        words = text.split()\n        modernized_words = []\n        changes_made = []\n        \n        for word in words:\n            clean_word = word.strip('.,!?;:\"()[]{}‡º≠')\n            punctuation = word[len(clean_word):]\n            \n            if clean_word in TAMIL_WORD_MAPPING:\n                modern_word = TAMIL_WORD_MAPPING[clean_word]\n                modernized_words.append(modern_word + punctuation)\n                if clean_word != modern_word:\n                    changes_made.append(f\"{clean_word} ‚Üí {modern_word}\")\n            else:\n                modernized_words.append(word)\n        \n        modernized_text = ' '.join(modernized_words)\n        \n        # Generate meaning explanation based on context\n        meaning_explanation = _generate_contextual_meaning_explanation(text, context_info)\n        \n        # Generate literary analysis\n        literary_analysis = _generate_basic_literary_analysis(text, context_info)\n        \n        return {\n            \"original_text\": text,\n            \"modernized_text\": modernized_text,\n            \"meaning_explanation\": meaning_explanation,\n            \"context_info\": context_info,\n            \"translation_method\": \"Context-based fallback\",\n            \"changes_made\": changes_made,\n            \"confidence\": 0.6,  # Lower confidence for fallback method\n            \"literary_analysis\": literary_analysis\n        }\n        \n    except Exception as e:\n        print(f\"Fallback translation error: {str(e)}\")\n        return {\n            \"original_text\": text,\n            \"modernized_text\": text,\n            \"meaning_explanation\": \"This appears to be classical Tamil poetry. Translation service temporarily unavailable.\",\n            \"context_info\": context_info or _fallback_classical_context(),\n            \"translation_method\": \"Minimal fallback\",\n            \"changes_made\": [],\n            \"confidence\": 0.3,\n            \"literary_analysis\": \"Classical Tamil text with traditional poetic elements.\"\n        }\n\ndef _generate_contextual_meaning_explanation(text: str, context_info: dict) -> str:\n    \"\"\"Generate meaning explanation based on context analysis\"\"\"\n    try:\n        themes = context_info.get('themes', ['classical poetry'])\n        period = context_info.get('period', 'Classical Tamil period')\n        significance = context_info.get('literary_significance', '')\n        \n        # Analyze text characteristics\n        text_length = len(text.split())\n        \n        if text_length <= 4:\n            meaning_base = \"This is a brief classical Tamil poetic phrase\"\n        elif text_length <= 10:\n            meaning_base = \"This appears to be a classical Tamil verse or couplet\"\n        else:\n            meaning_base = \"This is a substantial classical Tamil poetic composition\"\n        \n        # Add thematic context\n        if themes:\n            theme_text = ', '.join(themes[:3])\n            meaning_base += f\" with themes related to {theme_text}\"\n        \n        # Add historical context\n        meaning_base += f\" from the {period}.\"\n        \n        # Add significance if available\n        if significance and len(significance) > 50:\n            meaning_base += f\" {significance[:200]}...\"\n        \n        return meaning_base\n        \n    except Exception:\n        return \"This appears to be classical Tamil poetry with traditional linguistic patterns and cultural themes.\"\n\ndef _generate_basic_literary_analysis(text: str, context_info: dict) -> str:\n    \"\"\"Generate basic literary analysis based on text structure and context\"\"\"\n    try:\n        key_terms = extract_key_terms_from_tamil_text(text)\n        themes = context_info.get('themes', [])\n        \n        analysis = \"Classical Tamil poetry\"\n        \n        # Add structural observations\n        word_count = len(text.split())\n        if word_count <= 8:\n            analysis += \" in concise verse form\"\n        elif word_count <= 20:\n            analysis += \" with moderate complexity\"\n        else:\n            analysis += \" with elaborate expression\"\n        \n        # Add thematic elements\n        if themes:\n            analysis += f\", featuring {', '.join(themes[:2])} themes\"\n        \n        # Add linguistic observations\n        if key_terms:\n            analysis += \". Uses traditional Tamil poetic vocabulary\"\n        \n        analysis += \" with classical literary conventions.\"\n        \n        return analysis\n        \n    except Exception:\n        return \"Classical Tamil poetry with traditional elements and linguistic patterns.\"\n\ndef _fallback_classical_context() -> dict:\n    \"\"\"Provide fallback context information when web research is unavailable\"\"\"\n    return {\n        'context': 'Classical Tamil literature encompasses works from the Sangam period (3rd century BCE - 3rd century CE) through medieval times. These texts often feature sophisticated poetic devices, cultural themes, and linguistic complexity.',\n        'period': 'Classical Tamil period (Sangam era to Medieval)',\n        'themes': ['devotion', 'nature', 'love', 'heroism', 'philosophy', 'ethics'],\n        'meaning': 'This text represents classical Tamil poetic tradition. The archaic language and structure suggest it may be from ancient Tamil literature, requiring specialized knowledge for complete interpretation.',\n        'literary_significance': 'Tamil classical literature is among the world\\'s oldest literary traditions, preserving cultural heritage, philosophical insights, and linguistic evolution over millennia. These works contribute significantly to understanding ancient South Indian civilization and Tamil cultural identity.'\n    }","size_bytes":23682},"premium_tts_service.py":{"content":"\"\"\"\nPremium TTS service supporting multiple high-quality providers for Tamil\n\"\"\"\nimport io\nimport os\nimport requests\nimport json\nfrom gtts import gTTS\nfrom typing import Optional, Dict, Any\n\nclass PremiumTTSService:\n    \"\"\"High-quality TTS service with multiple provider support\"\"\"\n    \n    def __init__(self):\n        self.providers = {\n            'gtts': self._gtts_generate,\n            'elevenlabs': self._elevenlabs_generate,\n            'google_cloud': self._google_cloud_generate,\n            'azure': self._azure_generate\n        }\n    \n    def generate_speech(self, text: str, provider: str = 'gtts', **kwargs) -> Optional[bytes]:\n        \"\"\"Generate speech using specified provider\"\"\"\n        if provider not in self.providers:\n            raise ValueError(f\"Provider {provider} not supported\")\n        \n        try:\n            return self.providers[provider](text, **kwargs)\n        except Exception as e:\n            print(f\"TTS generation failed for {provider}: {str(e)}\")\n            # Fallback to gTTS\n            if provider != 'gtts':\n                return self._gtts_generate(text, **kwargs)\n            return None\n    \n    def _gtts_generate(self, text: str, voice_accent: str = 'com', slow: bool = False, **kwargs) -> Optional[bytes]:\n        \"\"\"Generate using Google Text-to-Speech (gTTS)\"\"\"\n        try:\n            tts = gTTS(text=text, lang='ta', slow=slow, tld=voice_accent)\n            audio_buffer = io.BytesIO()\n            tts.write_to_fp(audio_buffer)\n            audio_buffer.seek(0)\n            return audio_buffer.getvalue()\n        except Exception as e:\n            print(f\"gTTS error: {str(e)}\")\n            return None\n    \n    def _elevenlabs_generate(self, text: str, voice_id: str = None, **kwargs) -> Optional[bytes]:\n        \"\"\"Generate using ElevenLabs API (premium quality)\"\"\"\n        api_key = os.getenv('ELEVENLABS_API_KEY')\n        if not api_key:\n            return self._gtts_generate(text, voice_accent='com', slow=False, **kwargs)  # Fallback to gTTS\n        \n        # Use a Tamil-suitable voice or multilingual voice\n        default_voice_id = \"pNInz6obpgDQGcFmaJgB\"  # Adam (multilingual)\n        voice_id = voice_id or default_voice_id\n        \n        url = f\"https://api.elevenlabs.io/v1/text-to-speech/{voice_id}\"\n        \n        headers = {\n            \"Accept\": \"audio/mpeg\",\n            \"Content-Type\": \"application/json\",\n            \"xi-api-key\": api_key\n        }\n        \n        data = {\n            \"text\": text,\n            \"model_id\": \"eleven_multilingual_v2\",\n            \"voice_settings\": {\n                \"stability\": 0.5,\n                \"similarity_boost\": 0.75,\n                \"style\": 0.0,\n                \"use_speaker_boost\": True\n            }\n        }\n        \n        try:\n            response = requests.post(url, json=data, headers=headers, timeout=30)\n            if response.status_code == 200:\n                return response.content\n            else:\n                print(f\"ElevenLabs API error: {response.status_code}\")\n                return self._gtts_generate(text, voice_accent='com', slow=False, **kwargs)  # Fallback\n        except Exception as e:\n            print(f\"ElevenLabs request error: {str(e)}\")\n            return self._gtts_generate(text, voice_accent='com', slow=False, **kwargs)  # Fallback\n    \n    def _google_cloud_generate(self, text: str, voice_name: str = None, **kwargs) -> Optional[bytes]:\n        \"\"\"Generate using Google Cloud Text-to-Speech API\"\"\"\n        api_key = os.getenv('GOOGLE_CLOUD_API_KEY')\n        if not api_key:\n            return self._gtts_generate(text, voice_accent='com', slow=False, **kwargs)  # Fallback\n        \n        url = f\"https://texttospeech.googleapis.com/v1/text:synthesize?key={api_key}\"\n        \n        # Tamil voice configuration\n        voice_config = {\n            \"languageCode\": \"ta-IN\",\n            \"name\": voice_name or \"ta-IN-Standard-A\",\n            \"ssmlGender\": \"FEMALE\"\n        }\n        \n        audio_config = {\n            \"audioEncoding\": \"MP3\",\n            \"sampleRateHertz\": 24000\n        }\n        \n        data = {\n            \"input\": {\"text\": text},\n            \"voice\": voice_config,\n            \"audioConfig\": audio_config\n        }\n        \n        headers = {\"Content-Type\": \"application/json\"}\n        \n        try:\n            response = requests.post(url, json=data, headers=headers, timeout=30)\n            if response.status_code == 200:\n                result = response.json()\n                import base64\n                return base64.b64decode(result['audioContent'])\n            else:\n                print(f\"Google Cloud TTS error: {response.status_code}\")\n                return self._gtts_generate(text, voice_accent='com', slow=False, **kwargs)  # Fallback\n        except Exception as e:\n            print(f\"Google Cloud TTS request error: {str(e)}\")\n            return self._gtts_generate(text, voice_accent='com', slow=False, **kwargs)  # Fallback\n    \n    def _azure_generate(self, text: str, voice_name: str = None, **kwargs) -> Optional[bytes]:\n        \"\"\"Generate using Azure Speech Services\"\"\"\n        subscription_key = os.getenv('AZURE_SPEECH_KEY')\n        region = os.getenv('AZURE_SPEECH_REGION', 'eastus')\n        \n        if not subscription_key:\n            return self._gtts_generate(text, voice_accent='com', slow=False, **kwargs)  # Fallback\n        \n        # Get access token\n        token_url = f\"https://{region}.api.cognitive.microsoft.com/sts/v1.0/issuetoken\"\n        token_headers = {\"Ocp-Apim-Subscription-Key\": subscription_key}\n        \n        try:\n            token_response = requests.post(token_url, headers=token_headers, timeout=10)\n            access_token = token_response.text\n            \n            # Synthesize speech\n            tts_url = f\"https://{region}.tts.speech.microsoft.com/cognitiveservices/v1\"\n            \n            headers = {\n                \"Authorization\": f\"Bearer {access_token}\",\n                \"Content-Type\": \"application/ssml+xml\",\n                \"X-Microsoft-OutputFormat\": \"audio-16khz-128kbitrate-mono-mp3\"\n            }\n            \n            # SSML for Tamil\n            voice_name = voice_name or \"ta-IN-PallaviNeural\"\n            ssml = f\"\"\"\n            <speak version='1.0' xml:lang='ta-IN'>\n                <voice name='{voice_name}'>\n                    {text}\n                </voice>\n            </speak>\n            \"\"\"\n            \n            response = requests.post(tts_url, headers=headers, data=ssml.encode('utf-8'), timeout=30)\n            \n            if response.status_code == 200:\n                return response.content\n            else:\n                print(f\"Azure TTS error: {response.status_code}\")\n                return self._gtts_generate(text, voice_accent='com', slow=False, **kwargs)  # Fallback\n                \n        except Exception as e:\n            print(f\"Azure TTS request error: {str(e)}\")\n            return self._gtts_generate(text, voice_accent='com', slow=False, **kwargs)  # Fallback\n    \n    def get_available_providers(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Get available TTS providers with their capabilities\"\"\"\n        return {\n            'gtts': {\n                'name': 'Google Text-to-Speech (Free)',\n                'quality': 'Good',\n                'requires_api_key': False,\n                'languages': ['Tamil'],\n                'features': ['Multiple accents', 'Speed control']\n            },\n            'elevenlabs': {\n                'name': 'ElevenLabs (Premium)',\n                'quality': 'Excellent',\n                'requires_api_key': True,\n                'languages': ['Tamil (Multilingual)'],\n                'features': ['AI voices', 'Emotion control', 'High quality']\n            },\n            'google_cloud': {\n                'name': 'Google Cloud TTS (Professional)',\n                'quality': 'Excellent',\n                'requires_api_key': True,\n                'languages': ['Tamil (ta-IN)'],\n                'features': ['Neural voices', 'SSML support', 'Multiple voices']\n            },\n            'azure': {\n                'name': 'Microsoft Azure Speech (Professional)',\n                'quality': 'Excellent',\n                'requires_api_key': True,\n                'languages': ['Tamil (ta-IN)'],\n                'features': ['Neural voices', 'SSML support', 'Custom voices']\n            }\n        }","size_bytes":8376},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"gtts>=2.5.4\",\n    \"openai>=1.107.1\",\n    \"pandas>=2.3.2\",\n    \"psycopg2-binary>=2.9.10\",\n    \"sqlalchemy>=2.0.43\",\n    \"streamlit>=1.49.1\",\n]\n","size_bytes":289},"replit.md":{"content":"# Overview\n\nThis is a Tamil Poetry Text-to-Speech Converter built with Streamlit. The application converts Tamil Unicode poetry text to MP3 audio with voice narration, specifically designed to handle classical Tamil poetry by modernizing archaic words for better text-to-speech pronunciation and comprehension.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Frontend Architecture\n- **Framework**: Streamlit web application framework\n- **User Interface**: Simple web-based interface for text input and audio generation\n- **File Handling**: In-browser audio playback and MP3 download functionality\n\n## Backend Architecture\n- **Core Logic**: Python-based text processing and audio generation\n- **Text Processing**: Dictionary-based word replacement system for modernizing classical Tamil words\n- **Audio Generation**: Google Text-to-Speech (gTTS) integration for Tamil language synthesis\n- **Data Structure**: Dictionary mapping system for word translations stored in separate module\n\n## Text Processing Pipeline\n1. **Input Sanitization**: Removes punctuation while preserving word structure\n2. **Dictionary Lookup**: Maps classical/archaic Tamil words to modern equivalents\n3. **Text Reconstruction**: Rebuilds text with modern words while maintaining original punctuation\n4. **Audio Synthesis**: Converts processed text to speech using Tamil language models\n\n## Audio Processing\n- **Text-to-Speech Engine**: Google Text-to-Speech (gTTS) with Tamil language support\n- **Audio Format**: MP3 output format\n- **Memory Management**: Uses BytesIO buffer for in-memory audio processing\n- **Delivery Methods**: Both streaming playback and downloadable file generation\n\n# External Dependencies\n\n## Core Libraries\n- **streamlit**: Web application framework for user interface\n- **gtts**: Google Text-to-Speech API for Tamil audio synthesis\n- **io**: Standard library for in-memory file operations\n- **base64**: Standard library for audio file encoding/download links\n\n## Language Processing\n- **Custom Dictionary**: Internal Tamil word mapping system for classical-to-modern word conversion\n- **Unicode Support**: Full Tamil Unicode text processing capabilities\n\n## Third-party Services\n- **Google Text-to-Speech API**: External service dependency for audio generation\n- **Internet Connection**: Required for gTTS API calls\n\n## File System\n- **Memory-based Processing**: No persistent file storage, all operations in memory\n- **Temporary Audio Generation**: Audio files created dynamically without disk storage","size_bytes":2558},"tamil_dictionary.py":{"content":"\"\"\"\nTamil word mapping dictionary for converting old/classical Tamil words to modern equivalents\nThis helps improve text-to-speech pronunciation and comprehension\n\"\"\"\n\nTAMIL_WORD_MAPPING = {\n    # Classical/Old Tamil to Modern Tamil word mappings\n    \n    # Pronouns and common words\n    \"‡ÆÖ‡Æµ‡Æ©‡Øç\": \"‡ÆÖ‡Æµ‡Æ©‡Øç\",\n    \"‡ÆÖ‡Æµ‡Æ≥‡Øç\": \"‡ÆÖ‡Æµ‡Æ≥‡Øç\", \n    \"‡ÆÖ‡Æ§‡ØÅ\": \"‡ÆÖ‡Æ§‡ØÅ\",\n    \"‡Æ®‡Ææ‡Æ©‡Øç\": \"‡Æ®‡Ææ‡Æ©‡Øç\",\n    \"‡Æ®‡ØÄ\": \"‡Æ®‡ØÄ\",\n    \"‡Æ®‡Ææ‡ÆÆ‡Øç\": \"‡Æ®‡Ææ‡ÆÆ‡Øç\",\n    \"‡Æ®‡ØÄ‡Æô‡Øç‡Æï‡Æ≥‡Øç\": \"‡Æ®‡ØÄ‡Æô‡Øç‡Æï‡Æ≥‡Øç\",\n    \"‡ÆÖ‡Æµ‡Æ∞‡Øç\": \"‡ÆÖ‡Æµ‡Æ∞‡Øç\",\n    \"‡ÆÖ‡Æµ‡Æ∞‡Øç‡Æï‡Æ≥‡Øç\": \"‡ÆÖ‡Æµ‡Æ∞‡Øç‡Æï‡Æ≥‡Øç\",\n    \n    # Archaic words to modern equivalents\n    \"‡ÆØ‡Ææ‡Æ©‡Øç\": \"‡Æ®‡Ææ‡Æ©‡Øç\",\n    \"‡Æ®‡Æø‡Æ©‡Øç\": \"‡Æâ‡Æ©‡Øç\",\n    \"‡Æé‡Æ©‡Øç\": \"‡Æé‡Æ©‡Øç\",\n    \"‡Æâ‡Æ©‡Øç\": \"‡Æâ‡Æ©‡Øç\",\n    \"‡Æ§‡Æ©‡Øç\": \"‡Æ§‡Æ©‡Øç\",\n    \"‡ÆÖ‡Æµ‡Æ©‡Øç\": \"‡ÆÖ‡Æµ‡Æ©‡Øç\",\n    \n    # Classical Tamil poetry words\n    \"‡Æï‡Ææ‡Æ§‡Æ≤‡Øç\": \"‡Æï‡Ææ‡Æ§‡Æ≤‡Øç\",\n    \"‡Æ™‡ØÇ\": \"‡Æ™‡ØÇ\",\n    \"‡ÆÆ‡Æ≤‡Æ∞‡Øç\": \"‡Æ™‡ØÇ\",\n    \"‡Æï‡ÆÆ‡Æ≤\": \"‡Æ§‡Ææ‡ÆÆ‡Æ∞‡Øà\",\n    \"‡Æï‡ØÅ‡Æµ‡Æ≥‡Øà\": \"‡Æ®‡ØÄ‡Æ≤‡Øã‡Æ§‡Øç‡Æ™‡Æ≤\",\n    \"‡Æ§‡Æ≥‡Æø‡Æ∞‡Øç\": \"‡Æá‡Æ≥‡Æ®‡Øç‡Æ§‡Æ≥‡Æø‡Æ∞‡Øç\",\n    \n    # Time and nature words\n    \"‡Æ™‡Øä‡Æ¥‡ØÅ‡Æ§‡ØÅ\": \"‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç\",\n    \"‡Æµ‡Øá‡Æ©‡Æø‡Æ≤‡Øç\": \"‡Æï‡Øã‡Æü‡Øà\",\n    \"‡Æï‡ØÅ‡Æ≥‡Æø‡Æ∞‡Øç\": \"‡Æï‡ØÅ‡Æ≥‡Æø‡Æ∞‡Øç‡Æï‡Ææ‡Æ≤‡ÆÆ‡Øç\",\n    \"‡ÆÆ‡Æ¥‡Øà\": \"‡ÆÆ‡Æ¥‡Øà\",\n    \"‡Æá‡Æ≤‡Øà‡ÆØ‡ØÅ‡Æ§‡Æø‡Æ∞‡Øç\": \"‡Æá‡Æ≤‡Øà‡ÆØ‡ØÅ‡Æ§‡Æø‡Æ∞‡Øç‡Æï‡Ææ‡Æ≤‡ÆÆ‡Øç\",\n    \n    # Emotional and descriptive words\n    \"‡ÆÖ‡Æ¥‡Æï‡ØÅ\": \"‡ÆÖ‡Æ¥‡Æï‡ØÅ\",\n    \"‡Æá‡Æ©‡Æø‡ÆÆ‡Øà\": \"‡Æá‡Æ©‡Æø‡ÆÆ‡Øà\",\n    \"‡ÆÆ‡Æï‡Æø‡Æ¥‡Øç‡Æö‡Øç‡Æö‡Æø\": \"‡ÆÆ‡Æï‡Æø‡Æ¥‡Øç‡Æö‡Øç‡Æö‡Æø\",\n    \"‡Æ§‡ØÅ‡Æ©‡Øç‡Æ™‡ÆÆ‡Øç\": \"‡Æ§‡ØÅ‡Æ©‡Øç‡Æ™‡ÆÆ‡Øç\",\n    \"‡ÆÜ‡Æ©‡Æ®‡Øç‡Æ§‡ÆÆ‡Øç\": \"‡ÆÆ‡Æï‡Æø‡Æ¥‡Øç‡Æö‡Øç‡Æö‡Æø\",\n    \n    # Classical verbs to modern\n    \"‡Æö‡ØÜ‡ÆØ‡Øç\": \"‡Æö‡ØÜ‡ÆØ‡Øç\",\n    \"‡Æµ‡Ææ\": \"‡Æµ‡Ææ\",\n    \"‡Æ™‡Øã\": \"‡Æ™‡Øã\",\n    \"‡Æá‡Æ∞‡ØÅ\": \"‡Æá‡Æ∞‡ØÅ\",\n    \"‡Æ®‡Æø‡Æ≤‡Øç\": \"‡Æ®‡Æø‡Æ≤‡Øç\",\n    \"‡Æì‡Æü‡ØÅ\": \"‡Æì‡Æü‡ØÅ\",\n    \n    # Religious and spiritual terms\n    \"‡Æï‡Æü‡Æµ‡ØÅ‡Æ≥‡Øç\": \"‡Æï‡Æü‡Æµ‡ØÅ‡Æ≥‡Øç\",\n    \"‡Æá‡Æ±‡Øà\": \"‡Æï‡Æü‡Æµ‡ØÅ‡Æ≥‡Øç\",\n    \"‡Æ§‡ØÜ‡ÆØ‡Øç‡Æµ‡ÆÆ‡Øç\": \"‡Æï‡Æü‡Æµ‡ØÅ‡Æ≥‡Øç\",\n    \"‡ÆÜ‡Æ£‡Øç‡Æü‡Æµ‡Æ©‡Øç\": \"‡Æï‡Æü‡Æµ‡ØÅ‡Æ≥‡Øç\",\n    \n    # Body parts (classical to modern)\n    \"‡Æï‡Æ£‡Øç\": \"‡Æï‡Æ£‡Øç\",\n    \"‡Æï‡Øà\": \"‡Æï‡Øà\",\n    \"‡Æï‡Ææ‡Æ≤‡Øç\": \"‡Æï‡Ææ‡Æ≤‡Øç\",\n    \"‡Æ§‡Æ≤‡Øà\": \"‡Æ§‡Æ≤‡Øà\",\n    \"‡ÆÆ‡ØÅ‡Æï‡ÆÆ‡Øç\": \"‡ÆÆ‡ØÅ‡Æï‡ÆÆ‡Øç\",\n    \"‡Æâ‡Æü‡Æ≤‡Øç\": \"‡Æâ‡Æü‡Æ≤‡Øç\",\n    \n    # Colors\n    \"‡Æµ‡ØÜ‡Æ≥‡Øç‡Æ≥‡Øà\": \"‡Æµ‡ØÜ‡Æ≥‡Øç‡Æ≥‡Øà\",\n    \"‡Æï‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ\": \"‡Æï‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ\",\n    \"‡Æö‡Æø‡Æµ‡Æ™‡Øç‡Æ™‡ØÅ\": \"‡Æö‡Æø‡Æµ‡Æ™‡Øç‡Æ™‡ØÅ\",\n    \"‡Æ®‡ØÄ‡Æ≤‡ÆÆ‡Øç\": \"‡Æ®‡ØÄ‡Æ≤‡ÆÆ‡Øç\",\n    \"‡Æ™‡Æö‡ØÅ‡ÆÆ‡Øà\": \"‡Æ™‡Æö‡Øç‡Æö‡Øà\",\n    \"‡ÆÆ‡Æû‡Øç‡Æö‡Æ≥‡Øç\": \"‡ÆÆ‡Æû‡Øç‡Æö‡Æ≥‡Øç\",\n    \n    # Family relationships\n    \"‡Æ§‡Ææ‡ÆØ‡Øç\": \"‡ÆÖ‡ÆÆ‡Øç‡ÆÆ‡Ææ\",\n    \"‡Æ§‡Æ®‡Øç‡Æ§‡Øà\": \"‡ÆÖ‡Æ™‡Øç‡Æ™‡Ææ\",\n    \"‡ÆÆ‡Æï‡Æ©‡Øç\": \"‡ÆÆ‡Æï‡Æ©‡Øç\",\n    \"‡ÆÆ‡Æï‡Æ≥‡Øç\": \"‡ÆÆ‡Æï‡Æ≥‡Øç\",\n    \"‡Æö‡Æï‡Øã‡Æ§‡Æ∞‡Æ©‡Øç\": \"‡ÆÖ‡Æ£‡Øç‡Æ£‡Æ©‡Øç\",\n    \"‡Æö‡Æï‡Øã‡Æ§‡Æ∞‡Æø\": \"‡ÆÖ‡Æï‡Øç‡Æï‡Ææ\",\n    \n    # Classical Tamil literary words\n    \"‡Æ™‡Ææ‡Æü‡Æ≤‡Øç\": \"‡Æ™‡Ææ‡Æü‡Øç‡Æü‡ØÅ\",\n    \"‡Æï‡Æµ‡Æø‡Æ§‡Øà\": \"‡Æï‡Æµ‡Æø‡Æ§‡Øà\",\n    \"‡Æá‡Æö‡Øà\": \"‡Æá‡Æö‡Øà\",\n    \"‡Æ®‡Ææ‡Æü‡Øç‡Æü‡Æø‡ÆØ‡ÆÆ‡Øç\": \"‡Æ®‡Æü‡Æ©‡ÆÆ‡Øç\",\n    \"‡Æï‡Æ≤‡Øà\": \"‡Æï‡Æ≤‡Øà\",\n    \n    # Abstract concepts\n    \"‡ÆÖ‡Æ©‡Øç‡Æ™‡ØÅ\": \"‡ÆÖ‡Æ©‡Øç‡Æ™‡ØÅ\",\n    \"‡Æ™‡Æ±‡Øç‡Æ±‡ØÅ\": \"‡Æ™‡Æ±‡Øç‡Æ±‡ØÅ\",\n    \"‡Æµ‡ØÄ‡Æ∞‡ÆÆ‡Øç\": \"‡Æ§‡Øà‡Æ∞‡Æø‡ÆØ‡ÆÆ‡Øç\",\n    \"‡ÆÖ‡Æ±‡Æø‡Æµ‡ØÅ\": \"‡ÆÖ‡Æ±‡Æø‡Æµ‡ØÅ\",\n    \"‡Æû‡Ææ‡Æ©‡ÆÆ‡Øç\": \"‡ÆÖ‡Æ±‡Æø‡Æµ‡ØÅ\",\n    \"‡Æ™‡ØÅ‡Æ§‡Øç‡Æ§‡Æø\": \"‡ÆÖ‡Æ±‡Æø‡Æµ‡ØÅ\",\n    \n    # Geographic and nature terms\n    \"‡ÆÆ‡Æ≤‡Øà\": \"‡ÆÆ‡Æ≤‡Øà\",\n    \"‡Æï‡Æü‡Æ≤‡Øç\": \"‡Æï‡Æü‡Æ≤‡Øç\",\n    \"‡ÆÜ‡Æ±‡ØÅ\": \"‡Æ®‡§¶‡Æø\",\n    \"‡Æï‡Ææ‡Æü‡ØÅ\": \"‡Æï‡Ææ‡Æü‡ØÅ\",\n    \"‡Æµ‡Ææ‡Æ©‡ÆÆ‡Øç\": \"‡Æµ‡Ææ‡Æ©‡ÆÆ‡Øç\",\n    \"‡Æ™‡ØÇ‡ÆÆ‡Æø\": \"‡Æ™‡ØÇ‡ÆÆ‡Æø\",\n    \n    # Animals (classical names to common)\n    \"‡ÆØ‡Ææ‡Æ©‡Øà\": \"‡ÆØ‡Ææ‡Æ©‡Øà\",\n    \"‡Æ™‡ØÅ‡Æ≤‡Æø\": \"‡Æ™‡ØÅ‡Æ≤‡Æø\",\n    \"‡Æö‡Æø‡Æô‡Øç‡Æï‡ÆÆ‡Øç\": \"‡Æö‡Æø‡Æô‡Øç‡Æï‡ÆÆ‡Øç\",\n    \"‡Æï‡ØÅ‡Æ§‡Æø‡Æ∞‡Øà\": \"‡Æï‡ØÅ‡Æ§‡Æø‡Æ∞‡Øà\",\n    \"‡Æ™‡Æö‡ØÅ\": \"‡Æ™‡Æö‡ØÅ\",\n    \"‡Æ®‡Ææ‡ÆØ‡Øç\": \"‡Æ®‡Ææ‡ÆØ‡Øç\",\n    \n    # Birds\n    \"‡Æï‡Øã‡Æ¥‡Æø\": \"‡Æï‡Øã‡Æ¥‡Æø\",\n    \"‡Æï‡Ææ‡Æï‡ÆÆ‡Øç\": \"‡Æï‡Ææ‡Æï‡ÆÆ‡Øç\",\n    \"‡Æï‡Æø‡Æ≥‡Æø\": \"‡Æï‡Æø‡Æ≥‡Æø\",\n    \"‡ÆÆ‡ÆØ‡Æø‡Æ≤‡Øç\": \"‡ÆÆ‡ÆØ‡Æø‡Æ≤‡Øç\",\n    \"‡Æï‡ØÅ‡ÆØ‡Æø‡Æ≤‡Øç\": \"‡Æï‡ØÅ‡ÆØ‡Æø‡Æ≤‡Øç\",\n    \n    # Classical Tamil honorifics and titles\n    \"‡ÆÖ‡Æ∞‡Æö‡Æ©‡Øç\": \"‡Æ∞‡Ææ‡Æú‡Ææ\",\n    \"‡ÆÖ‡Æ∞‡Æö‡Æø\": \"‡Æ∞‡Ææ‡Æ£‡Æø\",\n    \"‡Æµ‡Øá‡Æ®‡Øç‡Æ§‡Æ©‡Øç\": \"‡Æ∞‡Ææ‡Æú‡Ææ\",\n    \"‡ÆÆ‡Æ©‡Øç‡Æ©‡Æ©‡Øç\": \"‡Æ∞‡Ææ‡Æú‡Ææ\",\n    \n    # Archaic question words\n    \"‡Æé‡Æµ‡Æ©‡Øç\": \"‡ÆØ‡Ææ‡Æ∞‡Øç\",\n    \"‡Æé‡Æµ‡Æ≥‡Øç\": \"‡ÆØ‡Ææ‡Æ∞‡Øç\",\n    \"‡Æé‡Æ§‡ØÅ\": \"‡Æé‡Æ©‡Øç‡Æ©\",\n    \"‡Æé‡Æô‡Øç‡Æï‡Øá\": \"‡Æé‡Æô‡Øç‡Æï‡Øá\",\n    \"‡Æé‡Æ™‡Øç‡Æ™‡Øã‡Æ§‡ØÅ\": \"‡Æé‡Æ™‡Øç‡Æ™‡Øã‡Æ§‡ØÅ\",\n    \"‡Æè‡Æ©‡Øç\": \"‡Æè‡Æ©‡Øç\",\n    \"‡Æé‡Æ™‡Øç‡Æ™‡Æü‡Æø\": \"‡Æé‡Æ™‡Øç‡Æ™‡Æü‡Æø\",\n    \n    # Numbers (where classical differs)\n    \"‡Æí‡Æ©‡Øç‡Æ±‡ØÅ\": \"‡Æí‡Æ©‡Øç‡Æ±‡ØÅ\",\n    \"‡Æá‡Æ∞‡Æ£‡Øç‡Æü‡ØÅ\": \"‡Æá‡Æ∞‡Æ£‡Øç‡Æü‡ØÅ\",\n    \"‡ÆÆ‡ØÇ‡Æ©‡Øç‡Æ±‡ØÅ\": \"‡ÆÆ‡ØÇ‡Æ©‡Øç‡Æ±‡ØÅ\",\n    \"‡Æ®‡Ææ‡Æ©‡Øç‡Æï‡ØÅ\": \"‡Æ®‡Ææ‡Æ©‡Øç‡Æï‡ØÅ\",\n    \"‡Æê‡Æ®‡Øç‡Æ§‡ØÅ\": \"‡Æê‡Æ®‡Øç‡Æ§‡ØÅ\",\n    \n    # Classical connectors\n    \"‡ÆÜ‡Æï‡Æµ‡Øá\": \"‡ÆÜ‡Æï‡Æµ‡Øá\",\n    \"‡ÆÜ‡Æ©‡Ææ‡Æ≤‡Øç\": \"‡ÆÜ‡Æ©‡Ææ‡Æ≤‡Øç\",\n    \"‡Æé‡Æ©‡Æµ‡Øá\": \"‡Æé‡Æ©‡Æµ‡Øá\",\n    \"‡ÆÆ‡Øá‡Æ≤‡ØÅ‡ÆÆ‡Øç\": \"‡ÆÆ‡Øá‡Æ≤‡ØÅ‡ÆÆ‡Øç\",\n    \"‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ\": \"‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ\",\n}\n\n# Additional mappings for common classical Tamil poetry words\nPOETRY_SPECIFIC_MAPPINGS = {\n    \"‡ÆÆ‡Æ£‡Æø\": \"‡Æ∞‡Æ§‡Øç‡Æ§‡Æø‡Æ©‡ÆÆ‡Øç\",\n    \"‡ÆÆ‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ\": \"‡ÆÆ‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ\", \n    \"‡Æ™‡Øä‡Æ©‡Øç\": \"‡Æ§‡Æô‡Øç‡Æï‡ÆÆ‡Øç\",\n    \"‡Æµ‡ØÜ‡Æ≥‡Øç‡Æ≥‡Æø\": \"‡Æµ‡ØÜ‡Æ≥‡Øç‡Æ≥‡Æø\",\n    \"‡Æá‡Æ∞‡ØÅ‡ÆÆ‡Øç‡Æ™‡ØÅ\": \"‡Æá‡Æ∞‡ØÅ‡ÆÆ‡Øç‡Æ™‡ØÅ\",\n    \"‡Æì‡Æ≤‡Øà\": \"‡Æá‡Æ≤‡Øà\",\n    \"‡Æ§‡Æ≥‡Æø‡Æ∞‡Øç\": \"‡Æá‡Æ≥‡Æ®‡Øç‡Æ§‡Æ≥‡Æø‡Æ∞‡Øç\",\n    \"‡Æµ‡ÆØ‡Æ≤‡Øç\": \"‡Æ®‡ØÜ‡Æ≤‡Øç‡Æµ‡ÆØ‡Æ≤‡Øç\",\n    \"‡Æ§‡Øã‡Æü‡Øç‡Æü‡ÆÆ‡Øç\": \"‡Æ§‡Øã‡Æü‡Øç‡Æü‡ÆÆ‡Øç\",\n    \"‡ÆÆ‡Æ∞‡ÆÆ‡Øç\": \"‡ÆÆ‡Æ∞‡ÆÆ‡Øç\",\n    \"‡Æï‡Æø‡Æ≥‡Øà\": \"‡Æï‡Æø‡Æ≥‡Øà\",\n    \"‡Æµ‡Øá‡Æ∞‡Øç\": \"‡Æµ‡Øá‡Æ∞‡Øç\",\n    \"‡Æ™‡Æü‡Øç‡Æü‡ØÅ\": \"‡Æ™‡Æü‡Øç‡Æü‡ØÅ\",\n    \"‡Æ™‡Æ∞‡ØÅ‡Æ§‡Øç‡Æ§‡Æø\": \"‡Æ™‡Æ∞‡ØÅ‡Æ§‡Øç‡Æ§‡Æø\",\n}\n\n# Merge poetry-specific mappings into main dictionary\nTAMIL_WORD_MAPPING.update(POETRY_SPECIFIC_MAPPINGS)\n","size_bytes":6177}},"version":1}